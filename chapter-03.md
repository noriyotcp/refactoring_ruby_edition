# Chapter 3: Bad Smells in Code

## Duplicated Code

単純にコードが重複している問題は、同じクラス内の２つのメソッドが同じ式を持っている場合である。Extract Method を用いて双方の箇所からコードを実行する

もう１つのよくある重複は２つの兄弟クラスに同じ式があることだ。双方のクラスでExtract Method を用いて、それからPull Up Method によって重複を除去する  

コードが似ているが同じではないとき、Extract Method を用いて似た部分と違う部分を分離する必要がある。Form Template Method も使えるだろう  

メソッドが同じことをしているがアルゴリズムが違う場合、２つのアルゴリズムのうち、より明確なほうを選択して、Substitute Algorithm (置換アルゴリズム) を使用することができる

重複がメソッドの中程にあるときは、Extract Surrounding Method を用いる

無関係の２つのクラスにコードが重複している場合は、１つのクラスで Extract Class かExtract Module を使用して、新しいコンポーネントをもう一方のクラスで使用することを検討する  

## Long Method

手続きが長くなればなるほど、理解しづらくなる

99％ の場合、メソッドの短縮に必要なのは Extract Method である  

Extract Method を使おうとすると、多くのパラメータと一時変数が抽出されたメソッドに渡され、結果として元のものよりもひどく読みにくくなったりする

一時変数を除去するには、Replace Temp with Query かReplace Temp with Chain が使用できる  

パラメータの長いリストはIntroduce Parameter Object and Preserve Whole Object によってスリム化できる  

それを試しても、まだ一時変数やパラメータが多すぎる場合は、どデカイ大砲を手に入れるときだ： Replace Method with Method Object である 

抽出するコードの塊をどのように特定するか？ 良いテクニックは、コメントを探すことだ。コメントはしばしばこの種の意味的な道のりを教えてくれる  

それが何をしているのかを示すコメントがあるコードのブロックは、そのコメントに基づいた名前のメソッドに置き換えることができる。説明が必要な場合は、1行でも抽出する価値がある  

条件文やループも抽出の兆候を示している。Decompose Conditional を使用して条件式を処理する  

Collection Closure Methods でループを置き換え、クロージャーメソッドとクロージャーそのものの呼び出しにおいて、Extract Method を使用することを検討する

## Large Class

クラスがあまりにも多くのことをやろうとすると、あまりにも多くのインスタンス変数が現れることになる。クラスにインスタンス変数が多すぎると、すぐにコードが重複することになる

Extract Class によっていくつかの変数をまとめることができる。各コンポーネントに適した変数を選択して一緒にする  

時には、クラスは全てのインスタンス変数を常に使用するわけではない。そのような場合は、Extract Class, Extract Module, Extract Subclass を何度も行うことができる

あまりにも多くのコードを持つクラスは、重複したコードやカオス、そして（突然の）死の主な温床となる  
最も単純な解決策は、クラスそのものの冗長性を排除することである  

膨大な変数の塊を持つクラスの場合と同様に、コードが多すぎるクラスの通常の解決策は、Extract Class, Extract Module, Extract Subclass のいずれかである  

便利な方法は、クライアントがクラスをどのように使用するかを決定し、これらの用途ごとにExtract Module を使用することである。それはクラスをさらに分割する方法についてのアイデアを与えてくれるだろう

## Long Parameter List

すでに知っているオブジェクトを要求することによって、1つのパラメータでデータを取得できる場合は、Use Replace Parameter with Method を使用する。 このオブジェクトはインスタンス変数でも、別のパラメータでも構わない  

オブジェクトから収集された一連のデータを取得し、それをオブジェクト自体に置き換えるには、Preserve Whole Object を使用する

論理オブジェクトのない複数のデータ項目がある場合は、Introduce Parameter Object を使用してそれらをまとめるか、Introduce Named Parameter を使用してなめらかさを改善する  

これらの変更を行うための重要な例外が1つある。  それは、呼び出されたオブジェクトから大きなオブジェクトへの依存関係を明示的に作成したくない場合である。 そのような場合、データを展開してパラメータとして送信するのは合理的だが、苦痛が伴うことに注意する

パラメータリストが長すぎたり、頻繁に変更されたりする場合は、依存関係の構造を再考する必要がある

## Shotgun Surgery

ある種の変更を行うたびに、多くの異なるクラスに小さな変更をしなくてはならない  
変更が至るところにある場合、見つけ出すのが難しく、重要な変更は見落としやすい  

この場合、Move Method とMove Field を使用して、全ての変更を1つのクラスに入れたいとする。良い候補となりそうなクラスが現在は全くない場合は、１つ作成する  

たいてい、Inline Class を使用して、一連の振る舞いをまとめることができる  
少しだけ変更が生じるが、それは簡単に対処することができる  

## Data Clumps

同じ3つまたは4つのデータ項目が複数の場所に見られることがよくある：2つのクラスのインスタンス変数、および多くのメソッドシグネチャのパラメータなど  

一緒にぶら下がっている束のデータは、自身のオブジェクトにする必要がある。最初のステップでは、（データの）塊がインスタンス変数として示される場所を探す  

クラス変数をオブジェクトに変換するには、インスタンス変数でExtract Classを使用する。次に、Introduce Parameter Object またはPreserve Whole Object を使用してメソッドシグネチャに注目し、それらをスリム化する  

すぐに役立つのは、多くのパラメータリストを縮小し、メソッド呼び出しを簡略化できることでである。新しいオブジェクトの属性の一部のみを使用するデータの塊については心配しなくてもよい  
2つ以上のインスタンス変数を新しいオブジェクトに置き換えさえすれば、有利になる  

良いテストは、データ値の1つを削除することである。これを行った場合、他のデータは意味をなさなくなるであろうか？  
意味をなさないのであれば、それは生まれて死ぬことになっているオブジェクトがあるという確かな兆候である  

インスタンス変数リストとパラメータリストを減らすことで、いくつかの悪い匂い(bad smells)は確実に除去されるが、オブジェクトを取得すると、素晴らしい香り(perfume) を作る機会が得られる  

これで、新しいクラスに移動できる振る舞いを示唆する、機能不全のケースを探すことができる  

## Primitive Obsession

ほとんどのプログラミング環境には2種類のデータがある  

Record types はデータを意味のあるグループへと構築する  
Primitive types は積み上げるブロックである  

## Case Statements

case 構文は重複を生み出してしまう。オブジェクト指向のポリモーフィズムの概念はこの問題に対処するエレガントな方法である  
case 構文を見かけたらポリモーフィズムを検討する

## Speculative Generality

多くのことをしていないクラスやモジュールがある場合は、Collapse Hierarchyを使用する。不必要な委任はInline Classで削除できる  

使用されていないパラメータを持つメソッドは、Remove Parameter の対象となる  
奇妙な名前で指定されたメソッドは、Rename Method でしっかりとした名前にしなければならない  

危うい一般性は、メソッド、コードブランチ、またはクラス全体の唯一のユーザーがテストケースである場合に検出できます。このタイプのコードが見つかった場合は、それを削除し、テストケースを実行する  

正規の機能を実行するテストケースのヘルパーであるメソッドまたはクラスがある場合は、もちろんそれを残しておく必要がある

## Temporary Field

時として、インスタンス変数が特定の状況でのみ設定されるオブジェクトとして現れる時もある  
そのようなコードは、理解するのが難しい、なぜならオブジェクトが全ての変数を必要とするためである  

Extract Class を使用して、孤立した変数のためのホームを作成し、変数に関する全てのコードをコンポーネントに入れる

変数が有効でない場合に、Introduce Null Object を使用して代替コンポーネントを作成することによって、条件分岐のコードを除去することができる

## Message Chains

クライアントがあるオブジェクトに別のオブジェクトを要求する際に、メッセージチェーンが見かけられる  

クライアントがまた別のオブジェクトに要求し、そのクライアントがまた別のオブジェクトに要求し・・・といった具合である  

get_this メソッドの長い行、または一時変数の連なりなどである  

このように誘導すると、クライアントがその経路の構造に結合される。中間にある関連を変更すると、クライアントも変更する必要がある  

ここでの手段は Hide Delegate である。原則として、Hide Delegate をチェーン内のすべてのオブジェクトに適用できる可能性はあるが、これを行うとすべての中間のオブジェクトが、middle man (後述) に変わることがよくある  

Extract Method を使用して必要なコードを取得し、Move Method でチェーンを押し下げることができるかどうかを確認してみる  

チェーン内のオブジェクトのいずれかのクライアントが残りの方法を誘導したい場合は、それを行うメソッドを追加する

## Middle Man

オブジェクトの主な機能の１つは、カプセル化である。他の世界からの内部の詳細を隠すことである  

カプセル化はよく委任によって実現される  

クラスのインターフェースを見て、メソッドの半分が他のクラスに移譲しているのを見つけ出す  

そのあと、Remove Middle Man を使用して、実際に何が起こっているのかを知っているオブジェクトと対話する  

いくつかのメソッドがあまり効果を上げていない場合は、Inline Method を使用して、呼び出し元でそれらをインライン展開する  

追加の振る舞いがある場合は、Replace Delegation with Hierarchyを使用して、実際のオブジェクトをモジュールにして、middle man の中でinclude する

これにより、すべての委任を追跡せずに振る舞いを拡張できる

## Inappropriate Intimacy

時折クラスは親密になりすぎ、他のプライベートな部分を掘り下げるのに時間がかかりすぎる

継承は親密になりすぎる場合がよくある（密結合になるということだろうか？）  

## Alternative Classes with Different Interfaces

同じことをするが、異なるシグネチャを持つメソッドに対しては、Rename Method を使用するが、しばしば十分には行かない  

このような場合、クラスはまだ十分ではない。プロトコルが同じになるまで、Move Method を使用して、振る舞いをクラスに移動する  

これを実現するためにコードを不必要に移動させなければならない場合は、Extract Module or Introduce Inheritance を使用して補う  

## Incomplete Library Class

ライブラリが完璧であることは稀である。Ruby のオープンクラスで、Move Method を使用して必要な振る舞いをライブラリのクラスに移動することによって、簡単に修正できる

## Data Class

データクラスは属性を持つクラスで、他には何もない。そのようなクラスは意味のないデータホルダーであり、ほとんどの場合他のクラスによって詳細に操作されていることは確実である  

変更すべきでないインスタンス変数について、Remove Setting Method を使用する。インスタンス変数のコレクションがある場合、適切にカプセル化されているかどうかを確認し、そうでない場合は、カプセル化を適用する

これらの取得方法と設定方法が他のクラスで使用されている場所を探す。Move Method を使用してデータクラスへ振る舞いを移動する

メソッド全体を移動できない場合は、Extract Method を使用して移動可能なメソッドを作成する。その後Hide Method をゲッターとセッターに使用することができる

## Refused Bequest

サブクラスは、親のメソッドとデータを継承する。しかし、もしそれらが与えられたものを欲しくない、もしくは必要としないのであればどうだろうか？  

よくある話は、階層が間違っているということである。新しい兄弟クラスを作成し、Push Down Method を使用して、不要なメソッドを兄弟クラスへと移動する  
そうすれば、親は何が共通しているものだけを保持すれば良い

## Comments

コメントを書いてはならないと言っているわけではないが、コメントが悪臭を放つものではなく、消臭剤として使われることがある  
大量のコメントを見て、コードが悪いからコメントがあるということに気づきにくい  

コードのブロックを説明するコメントが必要な場合は、Extract Method を試す。メソッドがすでに抽出されていても、それが何をするのかを説明するためにコメントが必要な場合は、Rename Method を使用する  

システムに要求されている状態に関していくつかのルールを記す必要がある場合は、Introduce Assertion を使用する

コメントを書く必要があると感じたなら、まずコードをリファクタリングする。そうすればコメントは余分なものになる

何をすべきかわからないときは、コメントを使用するのに適している  
何が起こっているのかを描写するのに加えて、コメントはまだ確信を持てない領域を示すことができる  
将来修正する人、特にその人が忘れやすい人なら、この種の情報は役に立つ

## Metaprogramming Madness

たいていの場合、Ruby の動的な性質は大きな利点をもたらすが、誤用される可能性もある。一部のメタプログラミングのテクニックは、結果としてコードを難読化させる

例えば、`method_missing` hook はしばしば理解しにくいコードをもたらしてしまう  

コーディング時にオブジェクトのインターフェースを決定できない場合には、強力なツールになる可能性があるが、絶対に必要な場合を除いて、Replace Dynamic Receptor with Dynamic Method Definition かもしくはシンプルにExtract Method を使用して`method_missing` の定義を削除する  

`method_missing` の定義が本当に必要な場合は、Isolate Dynamic Receptor を使用して関心を分離する

## Disjointed API

ライブラリはたいてい、柔軟性を最優先として書かれている。（ライブラリの）作者は、多くの様々な人々が多くの様々な方法によってそのライブラリを使用できるように、このような柔軟性を構築する必要がある  

この柔軟性は多くの設定オプションを備えた、比較的粒度の細かい、分離されたAPI となることがよくある

だが多くの場合、個々のプロジェクトはすべての設定オプションを活用することはない。同じ設定オプションが繰り返し使用されることになる  

このような場合は、Introduce Gateway を使用して簡潔な方法でAPI とやりとりをする  

Introduce Expression Builder を内部と外部のAPI 双方に適用してより円滑な方法でパブリック・インターフェースとやりとりをすることができる

## Repetitive Boilerplate

重複を除去する最も簡単な方法はExtract Method である。メソッドを抽出し、複数の箇所から呼び出す  

そのほか例として、Ruby の`attr_reader` がある。属性リーダーを実装することはオブジェクト指向言語では一般的なことであり、Ruby の作者(Matz) はそれらを宣言するための簡潔な方法を提供することに決めた  

Introduce Class Annotation では`attr_reader` が呼び出されるのと同じ方法でクラス定義からクラスメソッドを呼び出すことによって、クラスに注釈をつける必要がある  

宣言文でコードの目的を明確に捉えることができる場合、Introduce Class Annotation はコードの意図を明確にしてくれる
