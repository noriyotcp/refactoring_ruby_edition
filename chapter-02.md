# Chapter 2: Principles in Refactoring

## Defining Refactoring

「リファクタリング」は文脈によって２つの定義を持つ

１つ目の定義は名詞という形

- ソフトウェアの内部構造を変更してより理解しやすくすること。目に見える振る舞いを変えることなく修正しやすくすること

２つ目の定義は動詞という形

- 目に見える振る舞いを変えることなくリファクタリングし続け、それを適用することによりソフトウェアを再構築すること

**ソフトウェアを理解しやすくする変更だけがリファクタリングである。リファクタリングはソフトウェアの目に見える振る舞いは変更しない**

### The Two Hats

Kent Beck によるメタファー

- 新しい関数を追加するとき、既存のコードを変更してはいけない。単に機能を追加するだけである  
テストを追加して動作することを確認することにより、進捗を測定することができる

- リファクタするときは新たな関数を追加しないようにする。コードを再構築するのみ  
テストを追加しない（見落としがあった場合は別）

頻繁に帽子をかぶりなおすようなもの

## Why Should You Refactor?

### Refactoring Improves the Design of Software

リファクタリングがなければ、プログラムのデザインは腐っていき、その構造は失われる

正しい場所に置かれていない部分を削除するだけでも作業が捗る

コードの構造の喪失は累積効果がある。コードのデザインが見えなくなればなるほど、それを保つのが難しくなり、より急速に形骸化していく

定期的なリファクタリングはその形を保つのに役立つ

重複したコードを取り除くことはデザインの改善の重要な側面の１つである

コード量を減らすことはコードの修正において大きな違いをもたらす

重複を取り除くことにより、コードが一度に全てを語ってくれる。それが良いデザインの本質である

### Refactoring Makes Software Easier to Understand

プログラムが動作するようにする際、将来関わる開発者のことを考えていないのは問題である

リファクタリングに少し時間を費やすことは、コードをその目的についてやりとりしやすくする

### Refactoring Helps You Find Bugs

コードの理解を助けることで、バグを発見するのにも役立つ  
バグを発見するのが得意ではなくても、コードをリファクタリングすれば、コードが何をしているかを深く理解し、その新しい理解をコードに戻すことができる  
プログラムの構造を明確にすることで、いくつかの前提を明確にして、バグを必ず発見できる  

Kent Beck はしばしば彼自身について「私は偉大なプログラマーではない。 私はすばらしい習慣を持つ優れたプログラマーだ」と語る。リファクタリングは、堅牢なコードを書く際にはるかに効果的である

### Refactoring Helps You Program Faster

リファクタリングはより速くコードを書くのに役立つ

良いデザインは爆速のソフトウェア開発の本質である。確かに、爆速開発を可能にするのは良いデザインを作る際の完全なポイントである

- 良いデザインがなければしばらくは速く進むかもしれないが、貧弱なデザインではすぐにスピードが落ちてくる  
- 新しい機能を追加する代わりに、バグを探して修正するのに時間を費やすことになる  
- 変更によってシステムを理解し重複するコードを探す手間がかかるようになる  
- 新しい機能はオリジナルのコードベースにいくつもパッチを重ねたものになる  

良いデザインはソフトウェア開発の速度を維持する本質である。リファクタリングはより速く開発をする助けになる、なぜならそれがシステムのデザインが形骸化していくのを食い止めるから  

## When Should You Refactor?

### The Rule of Three

Don Roberts によるガイドライン

1. 最初はただ単にやる（コードを書く）  
2. 次に似たようなことをした際、重複にたじろぐかもしれないが、とにかくやる  
3. ３度目に似たようなことをしたら、リファクタリングする

**Three strikes and you refactor.**

### Refactor When You Add Function

一般的にリファクタリングが必要なときとは、あるソフトウェアに新しい機能を追加したいときである

1. リファクタリングする１番目の理由は、変更する必要があるコードを理解する手助けのためである

2. リファクタリングをするもう１つの理由は簡単に機能を追加するのに役立たない設計に対してである

一度リファクタリングすると、機能を追加することがはるかに迅速かつ円滑に進む

新しいフレームワークがリリースされたり、アプリケーションの一部を置き換える可能性のある新しいテクニックが見つかるときがある

コードの一部をフレームワークに置き換えると、既存のチームと新しいメンバーが理解できるコードが少なくなる

だがしかし、フレームワークを使用する場合、チームを活用して問題を診断できるだけでなく、そのフレームワークを使用しているコミュニティを活用することもできる

### Refactor When You Need to Fix a Bug

バグレポートを取得した場合、リファクタリングが必要な兆候である。バグが存在するかどうかを確認するコードが不十分であるため

### Refactor As You Do a Code Review

コードレビューは開発チームに知識を広げるのに役立つ

レビューは経験のある開発者たちがその知識を経験の少ない開発者たちに渡すのに役立つ

レビューはまた、人々に有用なアイデアを提案する機会を与える

リファクタリングはコードレビューにさらに確固たる結果をもたらすのに役立つ

## Why Refactoring Works

プログラムには２種類の価値がある： それらが今日してくれること、そして明日してくれること

プログラミングをしている時のほとんどは、我々は今日プログラムにしてほしいことに焦点を当てる。バグの修正にしろ機能追加にしろ、今日のプログラムを良くすることによって価値あるものにしている

今日の仕事ですることは十分わかっているが、明日のそれについてはよく知らない

リファクタリングはそこから抜け出す１つの道である。昨日の決定が今日になって意味をなさないということが判明したら、その決定を変更する

- 読みにくいプログラムは修正もしにくい
- 重複するロジックを持ったプログラムは修正しにくい
- 動作中のコードを変更することを余儀なくされるような、さらなる振る舞いが必要なプログラムは修正しにくい
- 複雑な条件分岐のロジックがあるプログラムは修正しにくい

## Indirection and Refactoring

間接的であるということは諸刃の刃である。１つのものを２つのピースに分けるたびに、管理することが増える  
オブジェクト間の移譲が重なり、プログラムが読みづらくなる

それでも間接的であることは元が取れる

- ロジックの共有を可能にするため。例えば、２箇所で実行されるサブメソッドや全てのサブクラスで共有されるスーパークラス内のメソッドなど  
- 意図と実装を別々に説明するため。各クラスや各メソッドの名前を選んだりすることは、自分が何を意図しているのかを説明するための機会を与えてくれる  
- 独立した変更のため。２箇所でオブジェクトを使用している。２つのケースのうちの１つの振る舞いを変更したいとする。もしオブジェクトを変更すれば、両方とも変更するリスクがある。だからまずサブクラスを作成し、変更するケースにおいてそちらを参照する。それでもう一方のケースにおいてうっかり変更してしまう恐れがなく、サブクラスを修正することができる  
- 条件分岐のロジックを暗号化するため。オブジェクトは素晴らしいメカニズムやポリモーフィックなメッセージを持ち、柔軟だが明確に条件分岐のロジックを表現する。明確な条件をメッセージへと変更することにより、重複を減らし、透明性を追加し、柔軟性を増すということなどが一度にできる


## Problems with Refactoring
### Changing Interfaces

インタフェースの早すぎる公表は良くない。コードの所有権のポリシーを変更してスムースにリファクタリングする

### Databases

リファクタリングにおいて問題となる領域はデータベースである  
データベースは変更しづらい。マイグレーションも慎重にやる  

### When Shouldn't You Refactor?

期限が近づいている場合を除いて、時間がないからといってリファクタリングを延期すべきではない  
経験上リファクタリングによって生産性の向上が見られた。十分な時間がないのはたいてい、リファクタリングを行う必要があるというサインである

## Refactoring and Design

リファクタリングは設計を補完する特別な役割がある

リファクタリングは柔軟性を犠牲にすることなくシンプルな設計を導くことができる。これにより設計プロセスはより簡単で負担の少ないものになる

## Refactoring and Performance

速いソフトウェアを書く３つの一般的なアプローチ

1. 時間の予算 (time budgeting)  
設計を分解するにつれてリソースに予算(時間とフットプリント)
が与えられる。コンポーネントは予算を超えてはならないが、予算の時間を交換するための仕組みは許される  

2. 継続的に注意を払う (the constant attention) アプローチ  
このアプローチでは、全てのプログラマーは常にパフォーマンスを高く保つことができる。これは直感的なアトラクションがあるが、うまく機能しない。パフォーマンスを改善する変更は通常、プログラムの動作を困難にし、開発を送らせてしまう  
これは、結果としてできるソフトウェアがより速い場合には割に合うが、通常そうではない  
全てのコードを同じように最適化すると、それほどうまく動作していないコードも最適化することになるため、最適化の90％が無駄になる  
明快さが欠如しているため、プログラムを速くするのに費やされた時間は全て無駄な時間になる

3. パフォーマンス改善の３番目のアプローチは、この90％の統計を活用している。このアプローチでは、パフォーマンスに注意を払わずに適切な方法でプログラムを構築していく。パフォーマンスを最適化する段階になってはじめて、パフォーマンスに注意を払う。それはたいてい開発の最後の段階である
